const { Client, GatewayIntentBits, REST, Routes, Collection } = require('discord.js');
const fs = require('fs');
const path = require('path');
require('dotenv').config();

// Importar o servidor de whitelist
const WhitelistServer = require('./modules/whitelist-server');
let whitelistServer = null;

const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildMembers
    ]
});

const clientId = process.env.CLIENT_ID;
const token = process.env.TOKEN;

// Cole√ß√£o para comandos
client.commands = new Collection();

// M√≥dulo de filtro de chat
let chatFilter;

// Carregar logger
const logger = require('./modules/logger');

// Fun√ß√£o para inicializar o servidor de whitelist
async function initWhitelistServer() {
    try {
        if (!whitelistServer) {
            console.log('üåê Iniciando servidor de whitelist...');
            whitelistServer = new WhitelistServer(client);
            await whitelistServer.start();
            console.log(`‚úÖ Servidor de whitelist iniciado na porta ${whitelistServer.options.port}`);
            
            // Criar diret√≥rio de frontend se n√£o existir
            const frontendPath = path.join(__dirname, 'whitelist-frontend');
            if (!fs.existsSync(frontendPath)) {
                fs.mkdirSync(frontendPath, { recursive: true });
                console.log('üìÅ Diret√≥rio de frontend criado');
                
                // O servidor j√° cria os arquivos b√°sicos ao iniciar
                console.log('‚úÖ Arquivos de frontend b√°sicos criados pelo servidor');
            }
            
            // Disponibilizar globalmente
            global.whitelistServer = whitelistServer;
            return whitelistServer;
        } else {
            return whitelistServer;
        }
    } catch (error) {
        console.error('‚ùå Erro ao iniciar servidor de whitelist:', error);
        return null;
    }
}

// Carregando comandos
const commandsPath = path.join(__dirname, 'commands');
if (fs.existsSync(commandsPath)) {
    const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));

    for (const file of commandFiles) {
        const filePath = path.join(commandsPath, file);
        try {
            // Tentar carregar o m√≥dulo de diferentes formas
            let command;
            try {
                command = require(filePath);
            } catch (importError) {
                console.error(`‚ùå Erro ao importar ${file}:`, importError);
                continue;
            }

            // Normalizar o comando
            const commandModule = command.default || command;
            
            // Se for o m√≥dulo de filtro de chat, armazen√°-lo separadamente
            if (file === 'chatfilter.js') {
                chatFilter = commandModule;
                if (commandModule.commands) {
                    client.commands.set(commandModule.commands.data.name, commandModule.commands);
                    console.log(`‚úÖ Comando de filtro carregado: ${commandModule.commands.data.name}`);
                }
                continue;
            }
            
            // Verificar diferentes formatos de comando
            if (commandModule.data && commandModule.execute) {
                // Slash command com data e execute
                client.commands.set(commandModule.data.name, commandModule);
                console.log(`‚úÖ Comando slash carregado: ${commandModule.data.name}`);
            } 
            else if (commandModule.execute) {
                // Comando legado
                const commandName = file.replace('.js', '');
                client.commands.set(commandName, commandModule);
                console.log(`‚úÖ Comando legado carregado: ${commandName}`);
            } 
            else {
                console.warn(`‚ö†Ô∏è Comando em ${filePath} n√£o tem propriedades necess√°rias.`);
            }
        } catch (error) {
            console.error(`‚ùå Erro ao carregar comando ${file}:`, error);
        }
    }
}

// Registrando comandos slash
async function registerCommands() {
    const commands = [];
    
    // Coletar comandos para registro
    for (const command of client.commands.values()) {
        if (command.data) {
            // Usar toJSON se dispon√≠vel, sen√£o usar diretamente
            const commandData = typeof command.data.toJSON === 'function' 
                ? command.data.toJSON() 
                : command.data;
            commands.push(commandData);
        }
    }

    console.log('üì§ Registrando comandos...');
    console.log(`üìã Total de comandos: ${commands.length}`);
    
    if (commands.length > 0) {
        const rest = new REST({ version: '10' }).setToken(token);
        
        try {
            await rest.put(Routes.applicationCommands(clientId), { body: commands });
            console.log('‚úÖ Comandos registrados!');
        } catch (error) {
            console.error(`‚ùå Erro ao registrar comandos: ${error}`);
        }
    } else {
        console.warn('‚ö†Ô∏è Nenhum comando para registrar!');
    }
}

// Evento quando o bot estiver pronto
client.once('ready', async () => {
    console.log(`‚úÖ Bot est√° online como ${client.user.tag}`);
    
    // Registrar comandos
    await registerCommands();
    
    // Verificar diret√≥rio de banco de dados
    const dbPath = path.join(__dirname, 'database');
    if (!fs.existsSync(dbPath)) {
        fs.mkdirSync(dbPath, { recursive: true });
        console.log('üìÅ Diret√≥rio de banco de dados criado');
    }
    
    // Iniciar servidor de whitelist
    await initWhitelistServer();
});

// Evento de mensagem (para o filtro de chat)
client.on('messageCreate', async (message) => {
    // Verificar se o m√≥dulo de filtro est√° dispon√≠vel
    if (chatFilter && chatFilter.handleMessage) {
        try {
            await chatFilter.handleMessage(message, client);
        } catch (error) {
            console.error('‚ùå Erro ao processar filtro de chat:', error);
            // Registrar o erro no sistema de logs
            try {
                await logger.logError(message.guild, 'filtro-chat', error, {
                    userId: message.author.id,
                    messageId: message.id,
                    channelId: message.channel.id,
                    content: message.content
                });
            } catch (logError) {
                console.error('‚ùå Erro ao registrar erro de filtro:', logError);
            }
        }
    }
});

// Evento de intera√ß√£o
client.on('interactionCreate', async (interaction) => {
    try {
        // Comandos slash
        if (interaction.isChatInputCommand()) {
            const command = client.commands.get(interaction.commandName);

            if (!command) {
                console.error(`‚ùå Comando ${interaction.commandName} n√£o encontrado.`);
                await interaction.reply({ 
                    content: 'Este comando n√£o est√° configurado corretamente.', 
                    ephemeral: true 
                });
                return;
            }

            try {
                await command.execute(interaction, client);
            } catch (error) {
                console.error(`‚ùå Erro executando o comando ${interaction.commandName}:`, error);
                
                // Registrar o erro no sistema de logs
                try {
                    await logger.logError(interaction.guild, `comando-${interaction.commandName}`, error, {
                        userId: interaction.user.id,
                        channelId: interaction.channelId
                    });
                } catch (logError) {
                    console.error('‚ùå Erro ao registrar erro de comando:', logError);
                }
                
                if (!interaction.replied && !interaction.deferred) {
                    await interaction.reply({ 
                        content: 'Ocorreu um erro ao executar este comando.', 
                        ephemeral: true 
                    }).catch(console.error);
                } else {
                    await interaction.editReply({
                        content: 'Ocorreu um erro ao executar este comando.'
                    }).catch(console.error);
                }
            }
        }
        
        // Bot√µes
        else if (interaction.isButton()) {
            const customId = interaction.customId;
            
            if (customId === 'start_whitelist' || customId === 'open_whitelist_modal') {
                const whitelistCommand = client.commands.get('whitelist');
                if (whitelistCommand && whitelistCommand.handleButton) {
                    await whitelistCommand.handleButton(interaction, client);
                }
            } 
            else if (customId.startsWith('approve_whitelist_') || 
                    customId.startsWith('reject_whitelist_')) {
                // Usar o manipulador de aprova√ß√£o/rejei√ß√£o do whitelist
                const whitelistCommand = client.commands.get('whitelist');
                if (whitelistCommand && whitelistCommand.handleApprovalButtons) {
                    await whitelistCommand.handleApprovalButtons(interaction, client);
                } else if (client.commands.get('wlnew') && client.commands.get('wlnew').handleButtonApproval) {
                    // Fallback para o comando wlnew se whitelist n√£o tiver o manipulador
                    await client.commands.get('wlnew').handleButtonApproval(interaction, client);
                } else {
                    console.error('‚ùå Manipuladores de aprova√ß√£o n√£o encontrados');
                    await interaction.reply({ 
                        content: 'Fun√ß√£o de aprova√ß√£o/rejei√ß√£o n√£o configurada.', 
                        ephemeral: true 
                    });
                }
            } 
            // Novos bot√µes espec√≠ficos para o servidor web
            else if (customId.startsWith('wl_approve_') || customId.startsWith('wl_reject_')) {
                const formId = customId.split('_')[2];
                const action = customId.startsWith('wl_approve_') ? 'aprovado' : 'rejeitado';
                
                if (!whitelistServer) {
                    await initWhitelistServer();
                }
                
                if (whitelistServer) {
                    try {
                        // Buscar formul√°rio
                        const form = whitelistServer.db.forms[formId];
                        
                        if (!form) {
                            await interaction.reply({
                                content: '‚ùå Formul√°rio n√£o encontrado ou j√° processado.',
                                ephemeral: true
                            });
                            return;
                        }
                        
                        // Confirmar a√ß√£o
                        await interaction.reply({
                            content: `‚ö†Ô∏è Tem certeza que deseja ${action === 'aprovado' ? 'aprovar' : 'rejeitar'} a whitelist de **${form.username}**?`,
                            ephemeral: true,
                            components: [
                                {
                                    type: 1,
                                    components: [
                                        {
                                            type: 2,
                                            style: action === 'aprovado' ? 3 : 4,
                                            label: 'Confirmar',
                                            custom_id: `confirm_${action}_${formId}`
                                        },
                                        {
                                            type: 2,
                                            style: 2,
                                            label: 'Cancelar',
                                            custom_id: 'cancel_action'
                                        }
                                    ]
                                }
                            ]
                        });
                    } catch (error) {
                        console.error('‚ùå Erro ao processar bot√£o de whitelist:', error);
                        await interaction.reply({
                            content: 'Ocorreu um erro ao processar esta a√ß√£o.',
                            ephemeral: true
                        });
                    }
                } else {
                    await interaction.reply({
                        content: '‚ùå Servidor de whitelist n√£o est√° dispon√≠vel.',
                        ephemeral: true
                    });
                }
            }
            // Confirma√ß√£o de a√ß√µes de whitelist
            else if (customId.startsWith('confirm_aprovado_') || customId.startsWith('confirm_rejeitado_')) {
                const [_, action, formId] = customId.split('_');
                
                await interaction.deferUpdate();
                
                if (!whitelistServer) {
                    await initWhitelistServer();
                }
                
                if (whitelistServer) {
                    try {
                        // Buscar formul√°rio
                        const form = whitelistServer.db.forms[formId];
                        
                        if (!form) {
                            await interaction.followUp({
                                content: '‚ùå Formul√°rio n√£o encontrado ou j√° processado.',
                                ephemeral: true
                            });
                            return;
                        }
                        
                        // Atualizar formul√°rio
                        form.status = action;
                        form.reviewedBy = interaction.user.tag;
                        form.reviewedAt = new Date().toISOString();
                        
                        // Salvar
                        whitelistServer.saveForms();
                        
                        // Notificar usu√°rio se tiver Discord ID
                        if (form.discordId) {
                            await whitelistServer.notifyUser(form, action, '');
                        }
                        
                        // Atualizar resposta
                        await interaction.editReply({
                            content: `‚úÖ Whitelist de **${form.username}** foi ${action} com sucesso!`,
                            components: []
                        });
                        
                    } catch (error) {
                        console.error('‚ùå Erro ao processar confirma√ß√£o:', error);
                        await interaction.followUp({
                            content: 'Ocorreu um erro ao processar esta a√ß√£o.',
                            ephemeral: true
                        });
                    }
                } else {
                    await interaction.followUp({
                        content: '‚ùå Servidor de whitelist n√£o est√° dispon√≠vel.',
                        ephemeral: true
                    });
                }
            }
            else if (customId === 'cancel_action') {
                await interaction.update({
                    content: '‚ùå A√ß√£o cancelada.',
                    components: []
                });
            }
        }
        
        // Modais
        else if (interaction.isModalSubmit()) {
            const customId = interaction.customId;
            
            if (customId === 'whitelist_modal') {
                const whitelistCommand = client.commands.get('whitelist');
                if (whitelistCommand && whitelistCommand.handleModal) {
                    await whitelistCommand.handleModal(interaction, client);
                }
            } else if (customId === 'whitelist_modal_new') {
                const wlnewCommand = client.commands.get('wlnew');
                if (wlnewCommand && wlnewCommand.handleModal) {
                    await wlnewCommand.handleModal(interaction, client);
                } else {
                    console.error('‚ùå M√©todo handleModal n√£o encontrado para wlnew');
                    await interaction.reply({ 
                        content: 'Erro ao processar o formul√°rio de whitelist.', 
                        ephemeral: true 
                    });
                }
            }
        }
    } catch (error) {
        console.error('‚ùå Erro geral na intera√ß√£o:', error);
        
        // Tentar registrar o erro
        try {
            if (interaction.guild) {
                await logger.logError(interaction.guild, 'interacao', error, {
                    userId: interaction.user?.id,
                    type: interaction.type,
                    commandName: interaction.commandName
                });
            }
        } catch (logError) {
            console.error('‚ùå Erro ao registrar erro de intera√ß√£o:', logError);
        }
        
        // Responder ao usu√°rio
        try {
            if (!interaction.replied && !interaction.deferred) {
                await interaction.reply({ 
                    content: 'Ocorreu um erro ao processar esta intera√ß√£o.', 
                    ephemeral: true 
                });
            } else {
                await interaction.editReply({ 
                    content: 'Ocorreu um erro ao processar esta intera√ß√£o.' 
                });
            }
        } catch (replyError) {
            console.error('‚ùå Erro ao tentar informar erro ao usu√°rio:', replyError);
        }
    }
});

// Tratamento de erros n√£o capturados
process.on('unhandledRejection', error => {
    console.error('Unhandled promise rejection:', error);
});

// Adicionar tratamento para encerrar o servidor web ao desconectar
process.on('SIGINT', async () => {
    console.log('üõë Encerrando aplica√ß√£o...');
    
    if (whitelistServer) {
        console.log('üåê Parando servidor de whitelist...');
        await whitelistServer.stop();
    }
    
    console.log('üëã Bot desconectado.');
    process.exit(0);
});

client.login(token);